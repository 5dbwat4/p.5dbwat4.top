{"version":3,"file":"create-2c70b56a.js","sources":["../../node_modules/.pnpm/vueuc@0.4.58_vue@3.3.11/node_modules/vueuc/es/overflow/src/index.js","../../node_modules/.pnpm/treemate@0.3.11/node_modules/treemate/es/utils.js","../../node_modules/.pnpm/treemate@0.3.11/node_modules/treemate/es/check.js","../../node_modules/.pnpm/treemate@0.3.11/node_modules/treemate/es/path.js","../../node_modules/.pnpm/treemate@0.3.11/node_modules/treemate/es/move.js","../../node_modules/.pnpm/treemate@0.3.11/node_modules/treemate/es/flatten.js","../../node_modules/.pnpm/treemate@0.3.11/node_modules/treemate/es/contains.js","../../node_modules/.pnpm/treemate@0.3.11/node_modules/treemate/es/create.js"],"sourcesContent":["/* eslint-disable @typescript-eslint/strict-boolean-expressions */\nimport { defineComponent, renderSlot, h, onMounted, ref, nextTick } from 'vue';\nimport { useSsrAdapter } from '@css-render/vue3-ssr';\nimport { c, cssrAnchorMetaName } from '../../shared';\nconst hiddenAttr = 'v-hidden';\nconst style = c('[v-hidden]', {\n    display: 'none!important'\n});\nexport default defineComponent({\n    name: 'Overflow',\n    props: {\n        getCounter: Function,\n        getTail: Function,\n        updateCounter: Function,\n        onUpdateCount: Function,\n        onUpdateOverflow: Function\n    },\n    setup(props, { slots }) {\n        const selfRef = ref(null);\n        const counterRef = ref(null);\n        function deriveCounter(options) {\n            const { value: self } = selfRef;\n            const { getCounter, getTail } = props;\n            let counter;\n            if (getCounter !== undefined)\n                counter = getCounter();\n            else {\n                counter = counterRef.value;\n            }\n            if (!self || !counter)\n                return;\n            if (counter.hasAttribute(hiddenAttr)) {\n                counter.removeAttribute(hiddenAttr);\n            }\n            const { children } = self;\n            if (options.showAllItemsBeforeCalculate) {\n                for (const child of children) {\n                    if (child.hasAttribute(hiddenAttr)) {\n                        child.removeAttribute(hiddenAttr);\n                    }\n                }\n            }\n            const containerWidth = self.offsetWidth;\n            const childWidths = [];\n            const tail = slots.tail ? getTail === null || getTail === void 0 ? void 0 : getTail() : null;\n            let childWidthSum = tail ? tail.offsetWidth : 0;\n            let overflow = false;\n            const len = self.children.length - (slots.tail ? 1 : 0);\n            for (let i = 0; i < len - 1; ++i) {\n                if (i < 0)\n                    continue;\n                const child = children[i];\n                if (overflow) {\n                    if (!child.hasAttribute(hiddenAttr)) {\n                        child.setAttribute(hiddenAttr, '');\n                    }\n                    continue;\n                }\n                else if (child.hasAttribute(hiddenAttr)) {\n                    child.removeAttribute(hiddenAttr);\n                }\n                const childWidth = child.offsetWidth;\n                childWidthSum += childWidth;\n                childWidths[i] = childWidth;\n                if (childWidthSum > containerWidth) {\n                    const { updateCounter } = props;\n                    for (let j = i; j >= 0; --j) {\n                        const restCount = len - 1 - j;\n                        if (updateCounter !== undefined) {\n                            updateCounter(restCount);\n                        }\n                        else {\n                            counter.textContent = `${restCount}`;\n                        }\n                        const counterWidth = counter.offsetWidth;\n                        childWidthSum -= childWidths[j];\n                        if (childWidthSum + counterWidth <= containerWidth || j === 0) {\n                            overflow = true;\n                            i = j - 1;\n                            if (tail) {\n                                // tail too long or 1st element too long\n                                // we only consider tail now\n                                if (i === -1) {\n                                    tail.style.maxWidth = `${containerWidth - counterWidth}px`;\n                                    tail.style.boxSizing = 'border-box';\n                                }\n                                else {\n                                    tail.style.maxWidth = '';\n                                }\n                            }\n                            const { onUpdateCount } = props;\n                            if (onUpdateCount)\n                                onUpdateCount(restCount);\n                            break;\n                        }\n                    }\n                }\n            }\n            const { onUpdateOverflow } = props;\n            if (!overflow) {\n                if (onUpdateOverflow !== undefined) {\n                    onUpdateOverflow(false);\n                }\n                counter.setAttribute(hiddenAttr, '');\n            }\n            else {\n                if (onUpdateOverflow !== undefined) {\n                    onUpdateOverflow(true);\n                }\n            }\n        }\n        const ssrAdapter = useSsrAdapter();\n        style.mount({\n            id: 'vueuc/overflow',\n            head: true,\n            anchorMetaName: cssrAnchorMetaName,\n            ssr: ssrAdapter\n        });\n        onMounted(() => deriveCounter({\n            showAllItemsBeforeCalculate: false\n        }));\n        // besides onMounted, other case should be manually triggered, or we shoud watch items\n        return {\n            selfRef,\n            counterRef,\n            sync: deriveCounter\n        };\n    },\n    render() {\n        const { $slots } = this;\n        // eslint-disable-next-line @typescript-eslint/no-floating-promises\n        nextTick(() => this.sync({\n            showAllItemsBeforeCalculate: false\n        }));\n        // It shouldn't have border\n        return h('div', {\n            class: 'v-overflow',\n            ref: 'selfRef'\n        }, [\n            renderSlot($slots, 'default'),\n            // $slots.counter should only has 1 element\n            $slots.counter\n                ? $slots.counter()\n                : h('span', {\n                    style: {\n                        display: 'inline-block'\n                    },\n                    ref: 'counterRef'\n                }),\n            // $slots.tail should only has 1 element\n            $slots.tail ? $slots.tail() : null\n        ]);\n    }\n});\n","export function toArray(arg) {\n    if (Array.isArray(arg))\n        return arg;\n    return [arg];\n}\n// Do not use enum for lint plugin has error\nexport const TRAVERSE_COMMAND = {\n    STOP: 'STOP'\n};\nexport function traverseWithCb(treeNode, callback) {\n    const command = callback(treeNode);\n    if (treeNode.children !== undefined && command !== TRAVERSE_COMMAND.STOP) {\n        treeNode.children.forEach((childNode) => traverseWithCb(childNode, callback));\n    }\n}\nexport function getNonLeafKeys(treeNodes, options = {}) {\n    const { preserveGroup = false } = options;\n    const keys = [];\n    const cb = preserveGroup\n        ? (node) => {\n            if (!node.isLeaf) {\n                keys.push(node.key);\n                traverse(node.children);\n            }\n        }\n        : (node) => {\n            if (!node.isLeaf) {\n                if (!node.isGroup)\n                    keys.push(node.key);\n                traverse(node.children);\n            }\n        };\n    function traverse(nodes) {\n        nodes.forEach(cb);\n    }\n    traverse(treeNodes);\n    return keys;\n}\nexport function isLeaf(rawNode, getChildren) {\n    const { isLeaf } = rawNode;\n    if (isLeaf !== undefined)\n        return isLeaf;\n    else if (!getChildren(rawNode))\n        return true;\n    return false;\n}\nexport function defaultGetChildren(node) {\n    return node.children;\n}\nexport function defaultGetKey(node) {\n    return node.key;\n}\nexport function isIgnored() {\n    return false;\n}\nexport function isShallowLoaded(rawNode, getChildren) {\n    const { isLeaf } = rawNode;\n    if (isLeaf === false && !Array.isArray(getChildren(rawNode)))\n        return false;\n    return true;\n}\nexport function isDisabled(rawNode) {\n    return rawNode.disabled === true;\n}\nexport function isExpilicitlyNotLoaded(rawNode, getChildren) {\n    return (rawNode.isLeaf === false && !Array.isArray(getChildren(rawNode)));\n}\nexport function isNodeInvalid(rawNode, getChildren) {\n    if (rawNode.isLeaf === true) {\n        const children = getChildren(rawNode);\n        if (Array.isArray(children) && children.length > 0)\n            return true;\n    }\n    return false;\n}\nexport function unwrapCheckedKeys(result) {\n    var _a;\n    if (result === undefined || result === null)\n        return [];\n    if (Array.isArray(result))\n        return result;\n    return (_a = result.checkedKeys) !== null && _a !== void 0 ? _a : [];\n}\nexport function unwrapIndeterminateKeys(result) {\n    var _a;\n    if (result === undefined || result === null || Array.isArray(result)) {\n        return [];\n    }\n    return (_a = result.indeterminateKeys) !== null && _a !== void 0 ? _a : [];\n}\nexport function merge(originalKeys, keysToAdd) {\n    const set = new Set(originalKeys);\n    keysToAdd.forEach((key) => {\n        if (!set.has(key)) {\n            set.add(key);\n        }\n    });\n    return Array.from(set);\n}\nexport function minus(originalKeys, keysToRemove) {\n    const set = new Set(originalKeys);\n    keysToRemove.forEach((key) => {\n        if (set.has(key)) {\n            set.delete(key);\n        }\n    });\n    return Array.from(set);\n}\nexport function isGroup(rawNode) {\n    return (rawNode === null || rawNode === void 0 ? void 0 : rawNode.type) === 'group';\n}\nexport function createIndexGetter(treeNodes) {\n    const map = new Map();\n    treeNodes.forEach((treeNode, i) => {\n        map.set(treeNode.key, i);\n    });\n    return (key) => { var _a; return (_a = map.get(key)) !== null && _a !== void 0 ? _a : null; };\n}\n","import { isExpilicitlyNotLoaded, merge, minus, traverseWithCb, TRAVERSE_COMMAND } from './utils';\nexport class SubtreeNotLoadedError extends Error {\n    constructor() {\n        super();\n        this.message =\n            'SubtreeNotLoadedError: checking a subtree whose required nodes are not fully loaded.';\n    }\n}\nfunction getExtendedCheckedKeySetAfterCheck(checkKeys, currentCheckedKeys, treeMate, allowNotLoaded) {\n    return getExtendedCheckedKeySet(currentCheckedKeys.concat(checkKeys), treeMate, allowNotLoaded, false);\n}\nfunction getAvailableAscendantNodeSet(uncheckedKeys, treeMate) {\n    const visitedKeys = new Set();\n    uncheckedKeys.forEach((uncheckedKey) => {\n        const uncheckedTreeNode = treeMate.treeNodeMap.get(uncheckedKey);\n        if (uncheckedTreeNode !== undefined) {\n            let nodeCursor = uncheckedTreeNode.parent;\n            while (nodeCursor !== null) {\n                if (nodeCursor.disabled)\n                    break;\n                if (visitedKeys.has(nodeCursor.key))\n                    break;\n                else {\n                    visitedKeys.add(nodeCursor.key);\n                }\n                nodeCursor = nodeCursor.parent;\n            }\n        }\n    });\n    return visitedKeys;\n}\nfunction getExtendedCheckedKeySetAfterUncheck(uncheckedKeys, currentCheckedKeys, treeMate, allowNotLoaded) {\n    const extendedCheckedKeySet = getExtendedCheckedKeySet(currentCheckedKeys, treeMate, allowNotLoaded, false);\n    const extendedKeySetToUncheck = getExtendedCheckedKeySet(uncheckedKeys, treeMate, allowNotLoaded, true);\n    const ascendantKeySet = getAvailableAscendantNodeSet(uncheckedKeys, treeMate);\n    const keysToRemove = [];\n    extendedCheckedKeySet.forEach((key) => {\n        if (extendedKeySetToUncheck.has(key) || ascendantKeySet.has(key)) {\n            keysToRemove.push(key);\n        }\n    });\n    keysToRemove.forEach((key) => extendedCheckedKeySet.delete(key));\n    return extendedCheckedKeySet;\n}\nexport function getCheckedKeys(options, treeMate) {\n    const { checkedKeys, keysToCheck, keysToUncheck, indeterminateKeys, cascade, leafOnly, checkStrategy, allowNotLoaded } = options;\n    if (!cascade) {\n        if (keysToCheck !== undefined) {\n            return {\n                checkedKeys: merge(checkedKeys, keysToCheck),\n                indeterminateKeys: Array.from(indeterminateKeys)\n            };\n        }\n        else if (keysToUncheck !== undefined) {\n            return {\n                checkedKeys: minus(checkedKeys, keysToUncheck),\n                indeterminateKeys: Array.from(indeterminateKeys)\n            };\n        }\n        else {\n            return {\n                checkedKeys: Array.from(checkedKeys),\n                indeterminateKeys: Array.from(indeterminateKeys)\n            };\n        }\n    }\n    const { levelTreeNodeMap } = treeMate;\n    let extendedCheckedKeySet;\n    if (keysToUncheck !== undefined) {\n        extendedCheckedKeySet = getExtendedCheckedKeySetAfterUncheck(keysToUncheck, checkedKeys, treeMate, allowNotLoaded);\n    }\n    else if (keysToCheck !== undefined) {\n        extendedCheckedKeySet = getExtendedCheckedKeySetAfterCheck(keysToCheck, checkedKeys, treeMate, allowNotLoaded);\n    }\n    else {\n        extendedCheckedKeySet = getExtendedCheckedKeySet(checkedKeys, treeMate, allowNotLoaded, false);\n    }\n    const checkStrategyIsParent = checkStrategy === 'parent';\n    const checkStrategyIsChild = checkStrategy === 'child' || leafOnly;\n    const syntheticCheckedKeySet = extendedCheckedKeySet;\n    const syntheticIndeterminateKeySet = new Set();\n    const maxLevel = Math.max.apply(null, Array.from(levelTreeNodeMap.keys()));\n    // cascade check\n    // 1. if tree is fully loaded, it just works\n    // 2. if the tree is not fully loaded, we assume that keys which is in not\n    //    loaded tree are not in checked keys\n    //    for example:\n    //    a -- b(fully-loaded)   -- c(fully-loaded)\n    //      |- d(partial-loaded) -- ?e(not-loaded)\n    //    in the case, `e` is assumed not to be checked, nor we can't calc `d`'s\n    //    and `a`'s status\n    for (let level = maxLevel; level >= 0; level -= 1) {\n        const levelIsZero = level === 0;\n        // it should exists, nor it is a bug\n        const levelTreeNodes = levelTreeNodeMap.get(level);\n        for (const levelTreeNode of levelTreeNodes) {\n            if (levelTreeNode.isLeaf)\n                continue;\n            const { key: levelTreeNodeKey, shallowLoaded } = levelTreeNode;\n            if (checkStrategyIsChild && shallowLoaded) {\n                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                levelTreeNode.children.forEach((v) => {\n                    if (!v.disabled &&\n                        !v.isLeaf &&\n                        v.shallowLoaded &&\n                        syntheticCheckedKeySet.has(v.key)) {\n                        syntheticCheckedKeySet.delete(v.key);\n                    }\n                });\n            }\n            if (levelTreeNode.disabled || !shallowLoaded) {\n                continue;\n            }\n            let fullyChecked = true;\n            let partialChecked = false;\n            let allDisabled = true;\n            // it is shallow loaded, so `children` must exist\n            for (const childNode of levelTreeNode.children) {\n                const childKey = childNode.key;\n                if (childNode.disabled)\n                    continue;\n                if (allDisabled)\n                    allDisabled = false;\n                if (syntheticCheckedKeySet.has(childKey)) {\n                    partialChecked = true;\n                }\n                else if (syntheticIndeterminateKeySet.has(childKey)) {\n                    partialChecked = true;\n                    fullyChecked = false;\n                    break;\n                }\n                else {\n                    fullyChecked = false;\n                    if (partialChecked) {\n                        break;\n                    }\n                }\n            }\n            if (fullyChecked && !allDisabled) {\n                if (checkStrategyIsParent) {\n                    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                    levelTreeNode.children.forEach((v) => {\n                        if (!v.disabled && syntheticCheckedKeySet.has(v.key)) {\n                            syntheticCheckedKeySet.delete(v.key);\n                        }\n                    });\n                }\n                syntheticCheckedKeySet.add(levelTreeNodeKey);\n            }\n            else if (partialChecked) {\n                syntheticIndeterminateKeySet.add(levelTreeNodeKey);\n            }\n            if (levelIsZero &&\n                checkStrategyIsChild &&\n                syntheticCheckedKeySet.has(levelTreeNodeKey)) {\n                syntheticCheckedKeySet.delete(levelTreeNodeKey);\n            }\n        }\n    }\n    return {\n        checkedKeys: Array.from(syntheticCheckedKeySet),\n        indeterminateKeys: Array.from(syntheticIndeterminateKeySet)\n    };\n}\n// unchecking is safe when doing cascade uncheck in async mode\nexport function getExtendedCheckedKeySet(checkedKeys, treeMate, allowNotLoaded, isUnchecking) {\n    const { treeNodeMap, getChildren } = treeMate;\n    const visitedKeySet = new Set();\n    const extendedKeySet = new Set(checkedKeys);\n    checkedKeys.forEach((checkedKey) => {\n        const checkedTreeNode = treeNodeMap.get(checkedKey);\n        if (checkedTreeNode !== undefined) {\n            traverseWithCb(checkedTreeNode, (treeNode) => {\n                if (treeNode.disabled) {\n                    return TRAVERSE_COMMAND.STOP;\n                }\n                const { key } = treeNode;\n                if (visitedKeySet.has(key))\n                    return;\n                visitedKeySet.add(key);\n                // Adding keys before loaded check is okay, since if not valid error\n                // would be thrown\n                extendedKeySet.add(key);\n                if (isExpilicitlyNotLoaded(treeNode.rawNode, getChildren)) {\n                    if (isUnchecking) {\n                        return TRAVERSE_COMMAND.STOP;\n                    }\n                    else if (!allowNotLoaded) {\n                        throw new SubtreeNotLoadedError();\n                    }\n                }\n            });\n        }\n    });\n    return extendedKeySet;\n}\n","export function getPath(key, { includeGroup = false, includeSelf = true }, treeMate) {\n    var _a;\n    const treeNodeMap = treeMate.treeNodeMap;\n    let treeNode = key === null || key === undefined ? null : (_a = treeNodeMap.get(key)) !== null && _a !== void 0 ? _a : null;\n    const mergedPath = {\n        keyPath: [],\n        treeNodePath: [],\n        treeNode: treeNode\n    };\n    if (treeNode === null || treeNode === void 0 ? void 0 : treeNode.ignored) {\n        mergedPath.treeNode = null;\n        return mergedPath;\n    }\n    while (treeNode) {\n        if (!treeNode.ignored && (includeGroup || !treeNode.isGroup)) {\n            mergedPath.treeNodePath.push(treeNode);\n        }\n        treeNode = treeNode.parent;\n    }\n    mergedPath.treeNodePath.reverse();\n    if (!includeSelf)\n        mergedPath.treeNodePath.pop();\n    mergedPath.keyPath = mergedPath.treeNodePath.map((treeNode) => treeNode.key);\n    return mergedPath;\n}\n","export function getFirstAvailableNode(nodes) {\n    if (nodes.length === 0)\n        return null;\n    const node = nodes[0];\n    if (node.isGroup || node.ignored || node.disabled) {\n        return node.getNext();\n    }\n    return node;\n}\nfunction rawGetNext(node, loop) {\n    const sibs = node.siblings;\n    const l = sibs.length;\n    const { index } = node;\n    if (loop) {\n        return sibs[(index + 1) % l];\n    }\n    else {\n        if (index === sibs.length - 1)\n            return null;\n        return sibs[index + 1];\n    }\n}\nfunction move(fromNode, dir, { loop = false, includeDisabled = false } = {}) {\n    const iterate = dir === 'prev' ? rawGetPrev : rawGetNext;\n    const getChildOptions = {\n        reverse: dir === 'prev'\n    };\n    let meet = false;\n    let endNode = null;\n    function traverse(node) {\n        if (node === null)\n            return;\n        if (node === fromNode) {\n            if (!meet) {\n                meet = true;\n            }\n            else if (!fromNode.disabled && !fromNode.isGroup) {\n                endNode = fromNode;\n                return;\n            }\n        }\n        else {\n            if ((!node.disabled || includeDisabled) &&\n                !node.ignored &&\n                !node.isGroup) {\n                endNode = node;\n                return;\n            }\n        }\n        if (node.isGroup) {\n            const child = getChild(node, getChildOptions);\n            if (child !== null) {\n                endNode = child;\n            }\n            else {\n                traverse(iterate(node, loop));\n            }\n        }\n        else {\n            const nextNode = iterate(node, false);\n            if (nextNode !== null) {\n                traverse(nextNode);\n            }\n            else {\n                const parent = rawGetParent(node);\n                if (parent === null || parent === void 0 ? void 0 : parent.isGroup) {\n                    traverse(iterate(parent, loop));\n                }\n                else if (loop) {\n                    traverse(iterate(node, true));\n                }\n            }\n        }\n    }\n    traverse(fromNode);\n    return endNode;\n}\nfunction rawGetPrev(node, loop) {\n    const sibs = node.siblings;\n    const l = sibs.length;\n    const { index } = node;\n    if (loop) {\n        return sibs[(index - 1 + l) % l];\n    }\n    else {\n        if (index === 0)\n            return null;\n        return sibs[index - 1];\n    }\n}\nfunction rawGetParent(node) {\n    return node.parent;\n}\nfunction getChild(node, options = {}) {\n    const { reverse = false } = options;\n    const { children } = node;\n    if (children) {\n        const { length } = children;\n        const start = reverse ? length - 1 : 0;\n        const end = reverse ? -1 : length;\n        const delta = reverse ? -1 : 1;\n        for (let i = start; i !== end; i += delta) {\n            const child = children[i];\n            if (!child.disabled && !child.ignored) {\n                if (child.isGroup) {\n                    const childInGroup = getChild(child, options);\n                    if (childInGroup !== null)\n                        return childInGroup;\n                }\n                else {\n                    return child;\n                }\n            }\n        }\n    }\n    return null;\n}\nexport const moveMethods = {\n    getChild() {\n        if (this.ignored)\n            return null;\n        return getChild(this);\n    },\n    getParent() {\n        const { parent } = this;\n        if (parent === null || parent === void 0 ? void 0 : parent.isGroup) {\n            return parent.getParent();\n        }\n        return parent;\n    },\n    getNext(options = {}) {\n        return move(this, 'next', options);\n    },\n    getPrev(options = {}) {\n        return move(this, 'prev', options);\n    }\n};\n","export function flatten(treeNodes, expandedKeys) {\n    const expandedKeySet = expandedKeys ? new Set(expandedKeys) : undefined;\n    const flattenedNodes = [];\n    function traverse(treeNodes) {\n        treeNodes.forEach((treeNode) => {\n            flattenedNodes.push(treeNode);\n            if (treeNode.isLeaf || !treeNode.children || treeNode.ignored)\n                return;\n            if (treeNode.isGroup) {\n                // group node shouldn't be expanded\n                traverse(treeNode.children);\n            }\n            else if (\n            // normal non-leaf node\n            expandedKeySet === undefined ||\n                expandedKeySet.has(treeNode.key)) {\n                traverse(treeNode.children);\n            }\n        });\n    }\n    traverse(treeNodes);\n    return flattenedNodes;\n}\n","export function contains(parent, child) {\n    const parentKey = parent.key;\n    // eslint-disable-next-line no-unmodified-loop-condition\n    while (child) {\n        if (child.key === parentKey)\n            return true;\n        child = child.parent;\n    }\n    return false;\n}\n","import { getCheckedKeys } from './check';\nimport { toArray, isDisabled, isLeaf, isGroup, isNodeInvalid, unwrapCheckedKeys, isShallowLoaded, unwrapIndeterminateKeys, getNonLeafKeys, isIgnored, defaultGetChildren, defaultGetKey } from './utils';\nimport { getPath } from './path';\nimport { moveMethods, getFirstAvailableNode } from './move';\nimport { flatten } from './flatten';\nimport { contains } from './contains';\nfunction createTreeNodes(rawNodes, treeNodeMap, levelTreeNodeMap, nodeProto, getChildren, parent = null, level = 0) {\n    const treeNodes = [];\n    rawNodes.forEach((rawNode, index) => {\n        var _a;\n        if (process.env.NODE_ENV !== 'production' &&\n            isNodeInvalid(rawNode, getChildren)) {\n            console.error('[treemate]: node', rawNode, 'is invalid');\n        }\n        const treeNode = Object.create(nodeProto);\n        treeNode.rawNode = rawNode;\n        treeNode.siblings = treeNodes;\n        treeNode.level = level;\n        treeNode.index = index;\n        treeNode.isFirstChild = index === 0;\n        treeNode.isLastChild = index + 1 === rawNodes.length;\n        treeNode.parent = parent;\n        if (!treeNode.ignored) {\n            const rawChildren = getChildren(rawNode);\n            if (Array.isArray(rawChildren)) {\n                treeNode.children = createTreeNodes(rawChildren, treeNodeMap, levelTreeNodeMap, nodeProto, getChildren, treeNode, level + 1);\n            }\n        }\n        treeNodes.push(treeNode);\n        treeNodeMap.set(treeNode.key, treeNode);\n        if (!levelTreeNodeMap.has(level))\n            levelTreeNodeMap.set(level, []);\n        (_a = levelTreeNodeMap.get(level)) === null || _a === void 0 ? void 0 : _a.push(treeNode);\n    });\n    return treeNodes;\n}\nexport function createTreeMate(rawNodes, options = {}) {\n    var _a;\n    const treeNodeMap = new Map();\n    const levelTreeNodeMap = new Map();\n    const { getDisabled = isDisabled, getIgnored = isIgnored, getIsGroup = isGroup, getKey = defaultGetKey } = options;\n    const _getChildren = (_a = options.getChildren) !== null && _a !== void 0 ? _a : defaultGetChildren;\n    const getChildren = options.ignoreEmptyChildren\n        ? (node) => {\n            const children = _getChildren(node);\n            if (Array.isArray(children)) {\n                if (!children.length)\n                    return null;\n                return children;\n            }\n            return children;\n        }\n        : _getChildren;\n    const nodeProto = Object.assign({\n        get key() {\n            // do not pass parent or related things to it\n            // the key need to be specified explicitly\n            return getKey(this.rawNode);\n        },\n        get disabled() {\n            return getDisabled(this.rawNode);\n        },\n        get isGroup() {\n            return getIsGroup(this.rawNode);\n        },\n        get isLeaf() {\n            return isLeaf(this.rawNode, getChildren);\n        },\n        get shallowLoaded() {\n            return isShallowLoaded(this.rawNode, getChildren);\n        },\n        get ignored() {\n            return getIgnored(this.rawNode);\n        },\n        contains(node) {\n            return contains(this, node);\n        }\n    }, moveMethods);\n    const treeNodes = createTreeNodes(rawNodes, treeNodeMap, levelTreeNodeMap, nodeProto, getChildren);\n    function getNode(key) {\n        if (key === null || key === undefined)\n            return null;\n        const tmNode = treeNodeMap.get(key);\n        if (tmNode && !tmNode.isGroup && !tmNode.ignored) {\n            return tmNode;\n        }\n        return null;\n    }\n    function _getNode(key) {\n        if (key === null || key === undefined)\n            return null;\n        const tmNode = treeNodeMap.get(key);\n        if (tmNode && !tmNode.ignored) {\n            return tmNode;\n        }\n        return null;\n    }\n    function getPrev(key, options) {\n        const node = _getNode(key);\n        if (!node)\n            return null;\n        return node.getPrev(options);\n    }\n    function getNext(key, options) {\n        const node = _getNode(key);\n        if (!node)\n            return null;\n        return node.getNext(options);\n    }\n    function getParent(key) {\n        const node = _getNode(key);\n        if (!node)\n            return null;\n        return node.getParent();\n    }\n    function getChild(key) {\n        const node = _getNode(key);\n        if (!node)\n            return null;\n        return node.getChild();\n    }\n    const treemate = {\n        treeNodes,\n        treeNodeMap,\n        levelTreeNodeMap,\n        maxLevel: Math.max(...levelTreeNodeMap.keys()),\n        getChildren,\n        getFlattenedNodes(expandedKeys) {\n            return flatten(treeNodes, expandedKeys);\n        },\n        getNode,\n        getPrev,\n        getNext,\n        getParent,\n        getChild,\n        getFirstAvailableNode() {\n            return getFirstAvailableNode(treeNodes);\n        },\n        getPath(key, options = {}) {\n            return getPath(key, options, treemate);\n        },\n        getCheckedKeys(checkedKeys, options = {}) {\n            const { cascade = true, leafOnly = false, checkStrategy = 'all', allowNotLoaded = false } = options;\n            return getCheckedKeys({\n                checkedKeys: unwrapCheckedKeys(checkedKeys),\n                indeterminateKeys: unwrapIndeterminateKeys(checkedKeys),\n                cascade,\n                leafOnly,\n                checkStrategy,\n                allowNotLoaded\n            }, treemate);\n        },\n        check(keysToCheck, checkedKeys, options = {}) {\n            const { cascade = true, leafOnly = false, checkStrategy = 'all', allowNotLoaded = false } = options;\n            return getCheckedKeys({\n                checkedKeys: unwrapCheckedKeys(checkedKeys),\n                indeterminateKeys: unwrapIndeterminateKeys(checkedKeys),\n                keysToCheck: keysToCheck === undefined || keysToCheck === null\n                    ? []\n                    : toArray(keysToCheck),\n                cascade,\n                leafOnly,\n                checkStrategy,\n                allowNotLoaded\n            }, treemate);\n        },\n        uncheck(keysToUncheck, checkedKeys, options = {}) {\n            const { cascade = true, leafOnly = false, checkStrategy = 'all', allowNotLoaded = false } = options;\n            return getCheckedKeys({\n                checkedKeys: unwrapCheckedKeys(checkedKeys),\n                indeterminateKeys: unwrapIndeterminateKeys(checkedKeys),\n                keysToUncheck: keysToUncheck === null || keysToUncheck === undefined\n                    ? []\n                    : toArray(keysToUncheck),\n                cascade,\n                leafOnly,\n                checkStrategy,\n                allowNotLoaded\n            }, treemate);\n        },\n        getNonLeafKeys(options = {}) {\n            return getNonLeafKeys(treeNodes, options);\n        }\n    };\n    return treemate;\n}\n"],"names":["hiddenAttr","style","c","VOverflow","defineComponent","props","slots","selfRef","ref","counterRef","deriveCounter","options","self","getCounter","getTail","counter","children","child","containerWidth","childWidths","tail","childWidthSum","overflow","len","i","childWidth","updateCounter","j","restCount","counterWidth","onUpdateCount","onUpdateOverflow","ssrAdapter","useSsrAdapter","cssrAnchorMetaName","onMounted","$slots","nextTick","h","renderSlot","toArray","arg","TRAVERSE_COMMAND","traverseWithCb","treeNode","callback","command","childNode","getNonLeafKeys","treeNodes","preserveGroup","keys","cb","node","traverse","nodes","isLeaf","rawNode","getChildren","defaultGetChildren","defaultGetKey","isIgnored","isShallowLoaded","isDisabled","isExpilicitlyNotLoaded","unwrapCheckedKeys","result","_a","unwrapIndeterminateKeys","merge","originalKeys","keysToAdd","set","key","minus","keysToRemove","isGroup","createIndexGetter","map","SubtreeNotLoadedError","getExtendedCheckedKeySetAfterCheck","checkKeys","currentCheckedKeys","treeMate","allowNotLoaded","getExtendedCheckedKeySet","getAvailableAscendantNodeSet","uncheckedKeys","visitedKeys","uncheckedKey","uncheckedTreeNode","nodeCursor","getExtendedCheckedKeySetAfterUncheck","extendedCheckedKeySet","extendedKeySetToUncheck","ascendantKeySet","getCheckedKeys","checkedKeys","keysToCheck","keysToUncheck","indeterminateKeys","cascade","leafOnly","checkStrategy","levelTreeNodeMap","checkStrategyIsParent","checkStrategyIsChild","syntheticCheckedKeySet","syntheticIndeterminateKeySet","maxLevel","level","levelIsZero","levelTreeNodes","levelTreeNode","levelTreeNodeKey","shallowLoaded","v","fullyChecked","partialChecked","allDisabled","childKey","isUnchecking","treeNodeMap","visitedKeySet","extendedKeySet","checkedKey","checkedTreeNode","getPath","includeGroup","includeSelf","mergedPath","getFirstAvailableNode","rawGetNext","loop","sibs","l","index","move","fromNode","dir","includeDisabled","iterate","rawGetPrev","getChildOptions","meet","endNode","getChild","nextNode","parent","rawGetParent","reverse","length","start","end","delta","childInGroup","moveMethods","flatten","expandedKeys","expandedKeySet","flattenedNodes","contains","parentKey","createTreeNodes","rawNodes","nodeProto","rawChildren","createTreeMate","getDisabled","getIgnored","getIsGroup","getKey","_getChildren","getNode","tmNode","_getNode","getPrev","getNext","getParent","treemate"],"mappings":"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","x_google_ignoreList":[0,1,2,3,4,5,6,7]}